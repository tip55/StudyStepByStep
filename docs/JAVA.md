## 基本类型，各占用多少字节？
```bash
整数类型：byte(1字节)、short(2字节)、int(4字节)、long(8字节)
浮点类型：float(4字节)、double(8字节)
字符型：char(2字节)
布尔型：boolean(1字节)
```
## String类
是否可修改？
```bash

```

## 类加载机制
```bash
常见的代码执行顺序？
父类静态变量->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量（父类实例成员变量）->父类构造函数->子类非静态变量（子类实例成员变量）->子类构造函数

类加载的几个阶段：加载 -> 连接（验证/准备/解析）-> 初始化。
加载：将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 的对象，用来描述类在方法区内的数据结构。
连接（验证）：包括类文件的结构检查、语义检查、字节码验证、二进制兼容性的验证。
连接（准备）：为类的静态变量分配内存空间，并设置对应JAVA类型的默认值。
连接（解析）：把类的二进制数据中的符号引用替换为直接引用（指针地址）。
初始化：按在类中定义的先后顺序执行类的初始化语句（静态变量的声明语句和静态代码块等），为类的静态变量赋予初始值。

特别注意：在类加载的初始化阶段，会先检查相关类是否被加载和连接，没有则触发加载和连接；若类存在直接的父类，会先对父类的加载和连接情况做检查；若都已加载和连接，再依次执行初始化语句。

```
## 类加载器
* 类型
根(Bootstrap)类加载器：它是最顶级加载器，负责加载虚拟机的核心类库（由系统属性sun.boot.class.path指定），如java.lang.*等。
扩展(Extension)类加载器：父加载器是根类加载器，负责加载由系统属性java.ext.dirs指定的目录中的类库，或者加载JDK目录的jre\lib\ext子目录的类库。
系统(System)类加载器：父加载器为扩展类加载器，负责加载环境变量classpath或者系统属性java.class.path指定的目录中的类。
除以上三种外，还有用户定义的类加载器。

* 父亲委托机制
类的加载过程出于系统的安全性考虑采用父亲委托机制进行，在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，防止不可靠代码代替由父加载器加载的可靠代码。
```bash
有以下加载器链：根类加载器 -> 扩展类加载器 -> 系统类加载器 -> userLoader1 -> userLoader2 。
对于下面的加载语句：
Class sampleClass = userLoader2.loadClass("xxxx.xxx.Sample");
userLoader2 先从自己的命名空间查找Sample类是否已被加载，已加载直接返回；
否则 userLoader2 先请求 userLoader1 代为加载，
userLoader1 请求 系统类加载器 代为加载，
系统类加载器 请求 扩展类加载器 代为加载，
扩展类加载器 请求 根类加载器 代为加载。
每个加载器都有其对应查找范围，若根类加载器在其范围未能查找并加载，则扩展类加载器尝试加载  ... ... ，
若加载成功，则将Sample类所对应的Class对象的引用向下依次返回到 userLoader1 ，来完成类加载。
```
* 命名空间
每个类加载器都有自己的命名空间，在同一个命名空间中，不会出现类的完整名字相同的两个类；但在不同的命名空间中可能出现类的完整名字相同的两个类。

## 反射的原理
反射机制允许程序在运行时动态取得任何一个已知名称的class的内部信息，包括其modifiers、superclass、实现的interfaces，也包括fields和methods的所有信息，并可于运行时改变fields值或调用methods。


